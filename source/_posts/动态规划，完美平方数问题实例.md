---
title: 动态规划，完美平方数问题实例
date: 2020-08-24 23:27:09
tags:
- 动态规划
- 完美平方数
- leetcode
categories:
- 算法
- leetcode
---

## leetCode原始问题描述
> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9,16, ...) which sum to n.For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.
> 假设有一个正整数n，找出相加等于n的最少的完美平方数的个数。（a^2=b,b为完美平方数)

## 《算法导论》中的动态规划
> 动态规划算法的设计分为四个步骤：
> 1.描述最优解的结构。
> 2.递归定义最优解的值。
> 3.按自底向上的方式计算**最优解**的值。
> 4.由计算的结果构造一个最优解。

## 关于本问题的思考
假设正整数n的完全平方数的个数和为f(n)。
1.最优解的情况，假设n=a^2,那么f(n)=1。
2.假设n = j*j + m,那么f(n) = 1 + f(m);(j*j < n)。
3.自底向上求解f(n)，即从f(1)开始一直到f(n).
4.遍历从1到j时，所有f(n)的取值，取最小的值，即为f(n)的最优解。


## 代码
```java
 public int solution(int n){
        int dp[] = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                /**
                 * dp[i]为完美平个数和
                 * i = (i-j*j)+j*j;
                 * dp[i] = dp[i-j*j]+dp[j*j]; dp[j*j]一定等于1
                 * dp[i] = dp[i-j*j]+1
                 * 假如i为完美平方数，dp[i] = 1;
                 * 所以取最小值
                 */
                dp[i] = Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
```
## 读完《数学之美》有限状态机和数据规划一章后对此问题的思考
《数学之美》中，关于动态规划问题的思考方法是：先假设问题的最优解的情况成立，然后将问题拆分成子问题，那么子问题是最优解的情况必定成立，否则就与原父问题是最优解的情况相矛盾。

而解决问题的关键就变为寻找子问题的最优解。最后一步步拆分子问题来进行递归，就能解决原问题。

即思考时整体从上到底，解决时从底到上。

用以上方法来分析此问题,dp[n]为n的最小完全平方个数和，现将问题拆分为子问题，拆分有如下两个步骤:
1. n = j*j + i
2. dp[n] = 1 + dp[i]
问题就变为求解dp[i]的子问题，代入递归，就可以求的dp[n]。
**这里还要注意第一步的拆解，因为j可以有多个值，比如6=1*1+5 或者 6=2*2+2 此时j有两种情况 j=1 j=2，只需将j等于多个值时求出的dp[n]相比较取最小值即可**